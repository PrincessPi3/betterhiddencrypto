x refactor to eliminate python because python is a tumor and i think i can do it better in shell script anyhoof
x refactor to use `mktemp` instead of ramdisk
randomized kdf values at both layers
    aes 256 gcm:
        aes_iv_length=$(random_val 12 32) # two digits
        aes_argon2id_salt_length=$(random_val 16 64) # two digits
        aes_argon2id_time_cost=$(random_val 016 128) # three digits
        aes_argon2id_memory_cost=$(random_val 16 18) # two digits
        aes_argon2id_paralellization=$(random_val 1 4) # one digit
    7zip crypto:
        7z_salt_length=$(random_val 16 64) # two digits
        7z_argon2id_time_cost=$(random_val 016 128) # three digits
        7z_argon2id_memory_cost=$(random_val 16 18) # two digits
        7z_argon2id_paralellization=$(random_val 1 4) # one digit

# globals
$bin_encrypted_archive_file_safe "$archive_name.bin"
$bin_archive_file_tmp=$(mktemp --dry-run)
$7z_archive_file_tmp=$(mktempv --dry-run)
# gloBALS (empty at start)
appended_aes_gcm_tag_hex_str=""
bin_archive_file_tmp=""
appended_aes_iv_hex_str=""
bin_archive_file_tmp=""
appended_aes_salt_hex_str=""
bin_archive_file_tmp=""
aes_key_derived_hex_str=""

File format
$bin_encrypted_archive_file_safe
    outer_volume_encrypted_bin
        $7z_archive_file_tmp:
            inner_volume_encrypted_7z
                secret files
                ...
                more secret files
            /inner_volume_encrypted_7z
            $appended_7z_salt
        /$7z_archive_file_tmp
    /outer_volume_encrypted_bin
    $appended_aes_gcm_tag_hex_str
    $appended_aes_iv_hex_str
    $appended_aes_salt_hex_str
/$bin_encrypted_archive_file_safe

program flow
decrypt:
    copy $bin_encrypted_archive_file_safe to $bin_archive_file_tmp
    derive $passphrase_checked_str to $7z_passphrase_str
        retreive and chop $appended_aes_salt_hex_str from $bin_archive_file_tmp
        derive $7z_passphrase_str from $passphrase_checked_str with $appended_aes_salt_hex_str via argon2id 
    retreive and chop $appended_aes_iv_hex_str from $bin_archive_file_tmp
    retreive and chop $appended_aes_gcm_tag_hex_str from $bin_archive_file_tmp
    attempt aes-256-gcm decrypt $bin_archive_file_tmp wtith digested $aes_key, $appended_aes_iv_hex_str, and $appended_aes_gcm_tag_hex_str
    fail:
        shred $bin_archive_file_tmp
        throw error message
        exit with error code
    success:
        inner volume (7z):
            $to_encrypt_dir_tmp=$(mktmp --directory)
            digest 7z passphrase
                reterive and chop $appended_7z_salt from $bin_archive_file_tmp
                derive $7z_passphrase_str using $passphrase_checked_str with $appended_7z_salt with argon2id
            7z decrypt/decompress $bin_archive_file_tmp to $to_encrypt_dir_tmp
                success:
                        shred file $bin_archive_file_tmp
                        shred file $7z_archive_file_tmp
                        print $to_encrypt_dir_tmp
                        exit 0
                fail:
                    shred $to_encrypt_dir_tmp
                    shred $bin_archive_tmp
                    shred $bin_archive_file_tmp
                    throw error message
                    exit with error code
encrypt:
    generate new salts and iv
    digest passphrase
        digest $7z_passphrase_str using $passphrase_checked_str with $appended_7z_salt with argon2id
    7z compress and encrypt $to_encrypt_dir_tmp with $7z_passphrase_str to $7z_archive_file_tmp
    7z verify $7z_archive_file_tmp archive with 7z a and $7z_passphrase_str
    append $appended_7z_salt to $7z_archive_file_tmp
    aes-256-gcm encrypt:
        encrypt $7z_archive_file_tmp with $aes_key_derived_hex_str and $appended_aes_iv_hex_str to $bin_archive_file_tmp
    append $appended_aes_gcm_tag_hex_str to $bin_archive_file_tmp
    append $appended_aes_iv_hex_str to $bin_archive_file_tmp
    append $appended_aes_salt_hex_str tto $bin_archive_file_tmp
    sanity check all appended:
        ripgrep find $appended_aes_gcm_tag_hex_str
        ripgrep find $appended_aes_iv_hex_str to $bin_archive_file_tmp
        ripgrep find $appended_aes_salt_hex_str tto $bin_archive_file_tmp
        fail:
            revert
                check reverteted $bin_archive_file_tmp matches $bin_archive_safe with checksum
                    fail:
                        notify
                        give sha512 checksums of remaining files
                        give locations of remaining files
                        exit with error code
                success:
                    notify
                    print temp file paths
                    exit with error code
        success:
            copy $bin_archive_file_tmp to $bin_encrypted_archive_file_safe
            shred $bin_archive_file_tmp
            shred $7z_archive_file_tmp
            shred $to_encrypt_dir_tmp
            exit 0
# new volume
## if $1 starts with N/n case insensitive
if [ "$mode" =~ ^[nN]{1} ]; then
    # get absolute path of $2
    bin_encrypted_archive_file_safe="$PWD/$(basename $2)"

    # make sure the arg is there
    if [ -z "$2" ]; then
        echo "FAIL no second argument"
        exit 1
    fi

    # ccheck if file exists
    if [ -f "$bin_encrypted_archive_file_safe" ]; then
        bin_encrypted_archive_file_safe="$bin_encrypted_archive_file_safe"
        decrypt
    fi

    # make the temp dir
    to_encrypt_dir_tmp=$(mktmp --directory --dry-run)

    # actually create the dir
    mkdir "$to_encrypt_dir_tmp"

    echo "$to_encrypt_dir_tmp"
    encrypt
fi
    
make generic argon2id digest function
    output hex string
    use cracklib-check to ensure password strength
    do sanity checks
    take argon2id settings as args / maybe have pre-defined presets it just picks between via arg $1
add cracklib-check test to encryption function
    echo -n "$passphrase" | cracklib-check
        dat -n ver important to make sure echo does no trailing newline
        really best audit rest of script for any failure of usin it frong
        cracklib-check still returns retcode 0 when pass fails test, figure out how to handle this frong
            figure it'll just ask for password twice,
                pass through cracklib-check,
                parse the output to check for OK$
                if OK, proceed, else loop back to try again instead of failing
make generic aes encryption and decryption functions
    use openssl
    feed it raw key hex string
    feed it randomly generated iv hex string
    append the iv hex string I think
make hex data extracting and appending functions
    work just like retrieve_7z_salt and append_7z_salt ig
    chops off the hex string and passes them to the functions wiht xxd -p as needed
make and clean up iv/salt generation function
    length via $1
    iv, 7z salt, and aes salt all changed to globals
    output hex string
    ~openssl rand -hex $n
support asshole yum usin linuxfuckers
sanity checks
    sanity checks on closing ramdisk
    redundant tests of each step before proceeding?
nuke/nuke reboot ask for confirm?
run out from one single shell script
    curl download installer oneliner frong (for ez and in case dey want it in their PATH)
autoinstaller on missing environment shit
    setup environment re ramdisk and file init
documentation
    update packages list
    update usage
    tidy up and spell out proper usage
        key selection
        key storage
        key backups
        tell em about
            threat model
                forensics
                theif
                    high end
                    low end
                malware
                leaks
                    password leaks from third party platforms
                    key/passphrase/secrets leak from betterhiddencrypto
                social engineering
                    phishing
            Discuss disk encryption
                LUKS
                    use in data destruction
optional offline haveibeenpwned testing?
remove vestigial code and comments
make generic functions for iv/salt generation, as well as iv/salt appending and retrieving
    dis way dey can be resused yyayy
    try to handle dem only as hex strings because fuckin nullbytes jfc god damned fuck
maybe fuckin rename those dickfuck file/archive var names they confusing as shit
add ramdisk function
hammer offline card for leaked bytes
    also leaked partial bytes
    also do hexdump analysis of the file system to try and find any remnants of empty directories
        figure out some way to make them vanish (srm again?)
hammer linux for leaks
hammer WSL for leaks
hammer memory for leaks
hammer for directory information leaks
full on forensic analysis
work on antiforensics
x rework readme
    x witches idea to append/prepend memorized string to stored pass for dual custody typr thinggg
    x actual instructions for usage
    x add mention of 7z crypto
readme
    flesh out how the modes work
    add nuke and antiforensics details
    prettify it
    add first pass digest/salt info
    add laymen usage for a normie to use it durably
        onedrive/cloud issue
        backup/file history issue
        beached pass issue
        secure pass creation
            kara's tip
        key management
        backing up encrypted data and keys durably
            backups leak issue again
x add password security 
add breached passwords check
X shred all volume crypto headers mode (shred --zero --remove --size=N (bytes))
    X also check for and shred any dangling files
    verify data durability in failure modes
    verify that enough bytes are shredded to reliably nuke it
    multithread nuke
    highest priority task setting?
    full system shred nuke mode?
        would have to do it in a clever order based on sensitivity, speed, and keeping the system running long enough to complete
x add smart optin to include dir or file on cli, or prombt for
x removed make install mode fuckin work
x prevent those errors when a .volume.bin or .volume.bin.bak is found
add network killswitch?
add configurable cron/backup operation kill/pause?
y make the sha512sum digest for 7z go through iterations and maybe use a salt
x    or find better alternative mayhaps
test install instructions
x add nuke options to help mode
make nuke silent
x verify salts are being used and stored and in digest
sanity check shit and error check
add known weaknesses to cryptanalysis readme
    both salts are leaked in the archive
        but their prsence still makes it far more robust against attack
        discuss the sha512 digest thinggg
            seek commentary
        discuss the 7z being used and the security threats involved in that
            seek commentary
        encrypted disk redundancy
            nuke mode for disk crypto?
multiple volume support
hidden volume/rubbehose type feature?
duress pass?
some type of dead man's switch to nuke?
tamper evident/tamper nuke?
memory shredding
cronjob canary for leaked/unencrypted data
store unencrypted files in memory only?
refactor into platform independant pure python?
    compiled python exe?
    gui for nomies? (REEEEE)
add more disclaimers about data loss and potentially bad security for fun
add debug mode to shell script and have it pass that to teh python script
    document
fork nuke to background and exit terminal?
    setsid <function> then clear/exit?
manually shred filenames by renaing repeatedly with junk and then nullbytes?
reevaluate workflow
    add option to specify input dir and output file
        smart select enc/dec with these
prepend outer layer salt to make nuking first n bytes easier and more effective
refactor to pure python
hidden volumes
randomness and correlation tests via
    entropy on a loop analysis
    dieharder
        randomness tests
        correlation tests
maybe:
    keyfiles
    yubikey crypto handshake thing
    dead man's switch (requires some kinda platform)
    duress passphrase (nukes)